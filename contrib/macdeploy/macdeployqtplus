
#!/usr/bin/env python3
#
# Copyright (C) 2011  Patrick "p2k" Schneider <me@p2k-network.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import subprocess, sys, re, os, shutil, stat, os.path, time
from string import Template
from argparse import ArgumentParser

# This is ported from the original macdeployqt with modifications

class FrameworkInfo(object):
    def __init__(self):
        self.frameworkDirectory = ""
        self.frameworkName = ""
        self.frameworkPath = ""
        self.binaryDirectory = ""
        self.binaryName = ""
        self.binaryPath = ""
        self.version = ""
        self.installName = ""
        self.deployedInstallName = ""
        self.sourceFilePath = ""
        self.destinationDirectory = ""
        self.sourceResourcesDirectory = ""
        self.sourceVersionContentsDirectory = ""
        self.sourceContentsDirectory = ""
        self.destinationResourcesDirectory = ""
        self.destinationVersionContentsDirectory = ""

    def __eq__(self, other):
        if self.__class__ == other.__class__:
            return self.__dict__ == other.__dict__
        else:
            return False

    def __str__(self):
        return """ Framework name: %s
 Framework directory: %s
 Framework path: %s
 Binary name: %s
 Binary directory: %s
 Binary path: %s
 Version: %s
 Install name: %s
 Deployed install name: %s
 Source file Path: %s
 Deployed Directory (relative to bundle): %s
""" % (self.frameworkName,
       self.frameworkDirectory,
       self.frameworkPath,
       self.binaryName,
       self.binaryDirectory,
       self.binaryPath,
       self.version,
       self.installName,
       self.deployedInstallName,
       self.sourceFilePath,
       self.destinationDirectory)

    def isDylib(self):
        return self.frameworkName.endswith(".dylib")

    def isQtFramework(self):
        if self.isDylib():
            return self.frameworkName.startswith("libQt")
        else:
            return self.frameworkName.startswith("Qt")

    reOLine = re.compile(r'^(.+) \(compatibility version [0-9.]+, current version [0-9.]+\)$')
    bundleFrameworkDirectory = "Contents/Frameworks"
    bundleBinaryDirectory = "Contents/MacOS"

    @classmethod
    def fromOtoolLibraryLine(cls, line):
        # Note: line must be trimmed
        if line == "":
            return None

        # Don't deploy system libraries (exception for libQtuitools and libQtlucene).
        if line.startswith("/System/Library/") or line.startswith("@executable_path") or (line.startswith("/usr/lib/") and "libQt" not in line):
            return None

        m = cls.reOLine.match(line)
        if m is None:
            raise RuntimeError("otool line could not be parsed: " + line)

        path = m.group(1)

        info = cls()
        info.sourceFilePath = path
        info.installName = path

        if path.endswith(".dylib"):
            dirname, filename = os.path.split(path)
            info.frameworkName = filename
            info.frameworkDirectory = dirname
            info.frameworkPath = path

            info.binaryDirectory = dirname
            info.binaryName = filename
            info.binaryPath = path
            info.version = "-"

            info.installName = path
            info.deployedInstallName = "@executable_path/../Frameworks/" + info.binaryName
            info.sourceFilePath = path
            info.destinationDirectory = cls.bundleFrameworkDirectory
        else:
            parts = path.split("/")
            i = 0
            # Search for the .framework directory
            for part in parts:
                if part.endswith(".framework"):
                    break
                i += 1
            if i == len(parts):
                raise RuntimeError("Could not find .framework or .dylib in otool line: " + line)

            info.frameworkName = parts[i]
            info.frameworkDirectory = "/".join(parts[:i])
            info.frameworkPath = os.path.join(info.frameworkDirectory, info.frameworkName)

            info.binaryName = parts[i+3]
            info.binaryDirectory = "/".join(parts[i+1:i+3])
            info.binaryPath = os.path.join(info.binaryDirectory, info.binaryName)
            info.version = parts[i+2]

            info.deployedInstallName = "@executable_path/../Frameworks/" + os.path.join(info.frameworkName, info.binaryPath)
            info.destinationDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, info.binaryDirectory)

            info.sourceResourcesDirectory = os.path.join(info.frameworkPath, "Resources")
            info.sourceContentsDirectory = os.path.join(info.frameworkPath, "Contents")
            info.sourceVersionContentsDirectory = os.path.join(info.frameworkPath, "Versions", info.version, "Contents")
            info.destinationResourcesDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, "Resources")
            info.destinationContentsDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, "Contents")
            info.destinationVersionContentsDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, "Versions", info.version, "Contents")

        return info

class ApplicationBundleInfo(object):
    def __init__(self, path):
        self.path = path
        appName = "GIANT-Qt"
        self.binaryPath = os.path.join(path, "Contents", "MacOS", appName)
        if not os.path.exists(self.binaryPath):
            raise RuntimeError("Could not find bundle binary for " + path)
        self.resourcesPath = os.path.join(path, "Contents", "Resources")
        self.pluginPath = os.path.join(path, "Contents", "PlugIns")

class DeploymentInfo(object):
    def __init__(self):
        self.qtPath = None
        self.pluginPath = None
        self.deployedFrameworks = []

    def detectQtPath(self, frameworkDirectory):
        parentDir = os.path.dirname(frameworkDirectory)
        if os.path.exists(os.path.join(parentDir, "translations")):
            # Classic layout, e.g. "/usr/local/Trolltech/Qt-4.x.x"
            self.qtPath = parentDir
        elif os.path.exists(os.path.join(parentDir, "share", "qt4", "translations")):
            # MacPorts layout, e.g. "/opt/local/share/qt4"
            self.qtPath = os.path.join(parentDir, "share", "qt4")
        elif os.path.exists(os.path.join(os.path.dirname(parentDir), "share", "qt4", "translations")):
            # Newer Macports layout
            self.qtPath = os.path.join(os.path.dirname(parentDir), "share", "qt4")
        else:
            self.qtPath = os.getenv("QTDIR", None)

        if self.qtPath is not None:
            pluginPath = os.path.join(self.qtPath, "plugins")
            if os.path.exists(pluginPath):
                self.pluginPath = pluginPath

    def usesFramework(self, name):
        nameDot = "%s." % name
        libNameDot = "lib%s." % name
        for framework in self.deployedFrameworks:
            if framework.endswith(".framework"):
                if framework.startswith(nameDot):
                    return True
            elif framework.endswith(".dylib"):
                if framework.startswith(libNameDot):
                    return True
        return False

def getFrameworks(binaryPath, verbose):
    if verbose >= 3:
        print("Inspecting with otool: " + binaryPath)
    otoolbin=os.getenv("OTOOL", "otool")
    otool = subprocess.Popen([otoolbin, "-L", binaryPath], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
    o_stdout, o_stderr = otool.communicate()
    if otool.returncode != 0:
        if verbose >= 1:
            sys.stderr.write(o_stderr)
            sys.stderr.flush()
            raise RuntimeError("otool failed with return code %d" % otool.returncode)

    otoolLines = o_stdout.split("\n")
    otoolLines.pop(0) # First line is the inspected binary
    if ".framework" in binaryPath or binaryPath.endswith(".dylib"):
        otoolLines.pop(0) # Frameworks and dylibs list themselves as a dependency.

    libraries = []
    for line in otoolLines:
        line = line.replace("@loader_path", os.path.dirname(binaryPath))
        info = FrameworkInfo.fromOtoolLibraryLine(line.strip())
        if info is not None:
            if verbose >= 3:
                print("Found framework:")
                print(info)
            libraries.append(info)

    return libraries

def runInstallNameTool(action, *args):
    installnametoolbin=os.getenv("INSTALLNAMETOOL", "install_name_tool")
    subprocess.check_call([installnametoolbin, "-"+action] + list(args))

def changeInstallName(oldName, newName, binaryPath, verbose):
    if verbose >= 3:
        print("Using install_name_tool:")
        print(" in", binaryPath)
        print(" change reference", oldName)
        print(" to", newName)
    runInstallNameTool("change", oldName, newName, binaryPath)

def changeIdentification(id, binaryPath, verbose):
    if verbose >= 3:
        print("Using install_name_tool:")
        print(" change identification in", binaryPath)
        print(" to", id)
    runInstallNameTool("id", id, binaryPath)

def runStrip(binaryPath, verbose):
    stripbin=os.getenv("STRIP", "strip")
    if verbose >= 3:
        print("Using strip:")
        print(" stripped", binaryPath)
    subprocess.check_call([stripbin, "-x", binaryPath])

def copyFramework(framework, path, verbose):
    if framework.sourceFilePath.startswith("Qt"):
        #standard place for Nokia Qt installer's frameworks
        fromPath = "/Library/Frameworks/" + framework.sourceFilePath
    else:
        fromPath = framework.sourceFilePath
    toDir = os.path.join(path, framework.destinationDirectory)
    toPath = os.path.join(toDir, framework.binaryName)

    if not os.path.exists(fromPath):
        raise RuntimeError("No file at " + fromPath)

    if os.path.exists(toPath):
        return None # Already there

    if not os.path.exists(toDir):
        os.makedirs(toDir)

    shutil.copy2(fromPath, toPath)
    if verbose >= 3:
        print("Copied:", fromPath)
        print(" to:", toPath)

    permissions = os.stat(toPath)
    if not permissions.st_mode & stat.S_IWRITE:
      os.chmod(toPath, permissions.st_mode | stat.S_IWRITE)

    if not framework.isDylib(): # Copy resources for real frameworks

        linkfrom = os.path.join(path, "Contents","Frameworks", framework.frameworkName, "Versions", "Current")
        linkto = framework.version
        if not os.path.exists(linkfrom):
            os.symlink(linkto, linkfrom)
            if verbose >= 2:
                print("Linked:", linkfrom, "->", linkto)
        fromResourcesDir = framework.sourceResourcesDirectory
        if os.path.exists(fromResourcesDir):
            toResourcesDir = os.path.join(path, framework.destinationResourcesDirectory)
            shutil.copytree(fromResourcesDir, toResourcesDir, symlinks=True)
            if verbose >= 3:
                print("Copied resources:", fromResourcesDir)
                print(" to:", toResourcesDir)
        fromContentsDir = framework.sourceVersionContentsDirectory
        if not os.path.exists(fromContentsDir):
            fromContentsDir = framework.sourceContentsDirectory
        if os.path.exists(fromContentsDir):
            toContentsDir = os.path.join(path, framework.destinationVersionContentsDirectory)
            shutil.copytree(fromContentsDir, toContentsDir, symlinks=True)
            if verbose >= 3:
                print("Copied Contents:", fromContentsDir)
                print(" to:", toContentsDir)
    elif framework.frameworkName.startswith("libQtGui"): # Copy qt_menu.nib (applies to non-framework layout)
        qtMenuNibSourcePath = os.path.join(framework.frameworkDirectory, "Resources", "qt_menu.nib")
        qtMenuNibDestinationPath = os.path.join(path, "Contents", "Resources", "qt_menu.nib")
        if os.path.exists(qtMenuNibSourcePath) and not os.path.exists(qtMenuNibDestinationPath):
            shutil.copytree(qtMenuNibSourcePath, qtMenuNibDestinationPath, symlinks=True)
            if verbose >= 3:
                print("Copied for libQtGui:", qtMenuNibSourcePath)
                print(" to:", qtMenuNibDestinationPath)

    return toPath

def deployFrameworks(frameworks, bundlePath, binaryPath, strip, verbose, deploymentInfo=None):
    if deploymentInfo is None:
        deploymentInfo = DeploymentInfo()

    while len(frameworks) > 0:
        framework = frameworks.pop(0)
        deploymentInfo.deployedFrameworks.append(framework.frameworkName)

        if verbose >= 2:
            print("Processing", framework.frameworkName, "...")

        # Get the Qt path from one of the Qt frameworks
        if deploymentInfo.qtPath is None and framework.isQtFramework():
            deploymentInfo.detectQtPath(framework.frameworkDirectory)

        if framework.installName.startswith("@executable_path") or framework.installName.startswith(bundlePath):
            if verbose >= 2:
                print(framework.frameworkName, "already deployed, skipping.")
            continue

        # install_name_tool the new id into the binary
        changeInstallName(framework.installName, framework.deployedInstallName, binaryPath, verbose)

        # Copy framework to app bundle.